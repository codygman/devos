#+PROPERTY: header-args :results silent :tangle yes


* common tasks
** switch to current configuration

#+begin_src sh :dir /sudo::/home/cody/flk :tangle no
  # takes a bit and no output :/
  nix-shell --run "flk NixOS switch"
#+end_src

** update all flake inputs

#+begin_src sh :dir ~/flk :tangle no :results verbatim
  # takes a bit and output has ansi noise
  # tried finding how to not do ansi but couldn't :/
  # nix-shell --run "nix flake update --recreate-lock-file"
  nix flake update --recreate-lock-file
#+end_src

** TODO searching for emacs packages available on nixpkgs

** TODO installing emacs packages from github with nix

*** trivial (no dependencies)

See [[*app-launcher][app-launcher]] example

*** TODO with dependencies

*** TODO using make

https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/editors/emacs-modes/emacspeak/default.nix

#+begin_src nix :tangle no
 stdenv, fetchurl, makeWrapper, emacs, tcl, tclx, espeak-ng, lib }:

stdenv.mkDerivation rec {
  pname = "emacspeak";
  version = "51.0";

  src = fetchurl {
    url = "https://github.com/tvraman/emacspeak/releases/download/${version}/${pname}-${version}.tar.bz2";
    sha256 = "09a0ywxlqa8jmc0wmvhaf7bdydnkyhy9nqfsdqcpbsgdzj6qpg90";
  };

  nativeBuildInputs = [ makeWrapper emacs ];
  buildInputs = [ tcl tclx espeak-ng ];

  preConfigure = ''
    make config
  '';

  postBuild = ''
    make -C servers/native-espeak PREFIX=$out "TCL_INCLUDE=${tcl}/include"
  '';

  postInstall = ''
    make -C servers/native-espeak PREFIX=$out install
    local d=$out/share/emacs/site-lisp/emacspeak/
    install -d -- "$d"
    cp -a .  "$d"
    find "$d" \( -type d -or \( -type f -executable \) \) -execdir chmod 755 {} +
    find "$d" -type f -not -executable -execdir chmod 644 {} +
    makeWrapper ${emacs}/bin/emacs $out/bin/emacspeak \
        --set DTK_PROGRAM "${espeak-ng}/bin/espeak" \
        --add-flags '-l "${placeholder "out"}/share/emacs/site-lisp/emacspeak/lisp/emacspeak-setup.elc"'
  '';

  meta = {
    homepage = "https://github.com/tvraman/emacspeak/";
    description = "Emacs extension that provides spoken output";
    license = lib.licenses.gpl2;
    maintainers = [ ];
    platforms = lib.platforms.linux;
  };
}
#+end_src

* install emacs
#+begin_src nix :noweb-ref emacs-system-dep :tangle no
emacsGcc
#+end_src
* Emacs appearance
** font
#+begin_src nix :noweb-ref emacs-system-dep :tangle no
inconsolata
#+end_src

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono for Powerline 16"))
#+end_src
** theme
#+begin_src nix :noweb-ref emacs-package :tangle no
modus-operandi-theme
modus-vivendi-theme
#+end_src

#+begin_src emacs-lisp :tangle yes
(load-theme 'modus-vivendi t)
#+end_src
** disable toolbar/scrollbar/etc

   We can do this in early-init.el to avoid any performance hit or visually seeing those things being disabled:

  ~NOTE~ This will only work on subsequent loads of emacs *after* this is tangled to the filesystem   

 #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref early-init
(push '(menu-bar-lines . 0) default-frame-alist) ;; remove mini menu
(push '(tool-bar-lines . 0) default-frame-alist) ;; remove tool icon
(push '(vertical-scroll-bars) default-frame-alist) ;; no scroll bar
 #+end_src
* Better emacs defaults
#+BEGIN_SRC emacs-lisp :noweb yes
<<better-defaults>>
#+END_SRC
** list
  :PROPERTIES:
  :header-args: :noweb-ref better-defaults :tangle no
  :END:
*** =y= not =yes= 
   #+begin_src emacs-lisp
    (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src
*** don't litter lock files or autosave files
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
      (make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)
      (setq auto-save-list-file-prefix (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory)
	    auto-save-file-name-transforms `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))
      ;; not recommended, but you may end up wanting to disable lock files that look like this:
      ;; ex. .#Emacs.org
      ;; (setq create-lockfiles nil)

      ;; I bet these need to be in the use-package declarations for these libs
      (setq projectile-known-projects-file (expand-file-name "tmp/projectile-bookmarks.eld" user-emacs-directory)
	    lsp-session-file (expand-file-name "tmp/.lsp-session-v1" user-emacs-directory))

      ;; or you might just want to use the no-littering package
      ;; https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Tips-Cleaning.org#no-littering

    #+end_src
*** remove initial scratch buffer message
   #+begin_src emacs-lisp
    (setq initial-scratch-message nil)
   #+end_src
*** set initial mode to org mode (includes scratch buffer)
   #+begin_src emacs-lisp
    (setq initial-major-mode 'org-mode)
   #+end_src

** disable startup screen
 #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref early-init
   (setq inhibit-startup-screen t
	 inhibit-startup-echo-area-message t)
 #+end_src
* General improvements
** line numbers
*** turn on line numbers globally
#+begin_src emacs-lisp
(global-display-line-numbers-mode t)
#+end_src
*** disable for some modes
#+begin_src emacs-lisp
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src
** TODO layout redo/undo with winner mode                       :superpower:
    #+begin_src emacs-lisp :noweb-ref winner-use-package :tangle no
      (use-package winner
        :config
        (winner-mode 1)
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'override
          :non-normal-prefix "M-SPC"
          :prefix "SPC"
          "wu" '(winner-undo :which-key "Winner Undo")
          "wr" '(winner-redo :which-key "Winner Redo")
          ))
    #+end_src
** rainbow delimiters
#+begin_src nix :noweb-ref emacs-package :tangle no
rainbow-delimiters
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** TODO nix mode
#+begin_src nix :noweb-ref emacs-package :tangle no
nix-mode
#+end_src

#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'")
#+end_src
** TODO investigate nix-emacs
https://github.com/travisbhartwell/nix-emacs
** TODO ghcid.el
:PROPERTIES:
:header-args: :tangle no :noweb no
:END:

#+begin_src nix
  # :noweb-ref emacs-package-in-let :tangle no
  ghcid-el = emacsPackages.trivialBuild {
    pname = "ghcid";
    src = prev.fetchurl {
      url = "https://raw.githubusercontent.com/ndmitchell/ghcid/master/plugins/emacs/ghcid.el";
      sha256 = "01n4fwqabx6jdyjqqi1hrpldaf28pib7zm4qcv99ghmrca6qk4xc";
    };
  };
#+end_src


#+begin_src nix
# :noweb-ref emacs-package :tangle no
ghcid-el
#+end_src

** app-launcher
#+begin_src nix :noweb-ref emacs-package-in-let :tangle no
  app-launcher = emacsPackages.trivialBuild {
    pname = "app-launcher";
    src = prev.fetchurl {
      url = "https://raw.githubusercontent.com/SebastienWae/app-launcher/master/app-launcher.el";
      sha256 = "bA4d4DvBfobS+sZz6rfrYAVAX6ct8qqUO59LCghR+iQ=";
    };
  };
#+end_src


#+begin_src nix :noweb-ref emacs-package :tangle no
app-launcher
#+end_src

#+begin_src emacs-lisp
  (use-package app-launcher)
#+end_src

** TODO enhanced emacs xwidgets browser

#+begin_src nix :noweb-ref emacs-package :tangle no
xwwp
#+end_src

#+begin_src emacs-lisp
  (use-package xwwp-follow-link)
#+end_src


** TODO real auto save mode
** TODO which key

*** get it installed/activated

The integration with selectrum will be a little different I think

#+begin_src nix :noweb-ref emacs-package :tangle no
which-key
#+end_src

#+begin_src emacs-lisp
  (use-package which-key :config (which-key-mode) :diminish t)
#+end_src

*** TODO actually show it in consult with [[*marginala][marginala]]

** TODO helpful (help with examples)
* Emacs package installation
** packages are pulled with nix
*** example 
    #+begin_src org :tangle no
      ,#+begin_src nix :noweb-ref emacs-package :tangle no
      use-package
      ,#+end_src
    #+end_src
** prevent use-package from pulling packages
*** Set ensure-function to nil
    #+begin_src emacs-lisp
      (setq use-package-ensure-function 'ignore)
    #+end_src

*** Set package-archives to nil so there's nothing to install from

    Package should already be there, to add a new one add it to home.nix

    #+begin_src emacs-lisp
      (setq package-archives nil)
    #+end_src
** configured with [[*setup use-package][use-package]]
* setup use-package
#+begin_src nix :noweb-ref emacs-package :tangle no
use-package
#+end_src
#+begin_src emacs-lisp
(require 'use-package)
#+end_src
* vim emulation with evil
** evil 

#+begin_src nix :noweb-ref emacs-package :tangle no
evil
#+end_src

#+begin_src emacs-lisp
    (use-package evil
      :after general
      :init
      (setq evil-want-keybinding nil
	    evil-want-C-d-scroll t
	    evil-want-C-u-scroll t
	    evil-want-integration t
	    evil-symbol-word-search t
	    )
      :config
      (setq evil-ex-substitute-global t)
      (setq evil-undo-system 'undo-redo)
      (evil-mode 1)
      )
#+end_src
** evil collection

#+begin_src nix :noweb-ref emacs-package :tangle no
evil-collection
#+end_src

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

* setup general.el and core keybindings
** unliterate setup
#+begin_src nix :noweb-ref emacs-package :tangle no
general
#+end_src

#+begin_src emacs-lisp :noweb yes
  (use-package general
    :init
    (setq evil-want-keybinding nil
	  evil-want-C-d-scroll t
	  evil-want-C-u-scroll t
	  evil-want-integration t
	  )
    <<general-init>>
    :config
    (general-auto-unbind-keys) ;; NOTE not sure this works?
    (general-evil-setup t)
    <<general-config>>
    (general-imap "j"
      (general-key-dispatch 'self-insert-command
	:timeout 0.25
	"f" 'evil-normal-state))
    (general-create-definer my-leader-def
      :prefix "C")
    (my-leader-def
      :states '(normal visual emacs motion)
      :prefix "SPC"
      :keymaps 'override
      :non-normal-prefix "M-SPC"
      "u"   '(universal-argument :which-key "Universal Argument")
      "tf" '(toggle-frame-fullscreen :which-key "Toggle Fullscreen")
      "wd" '(delete-window :which-key "Delete Window")
      "qq" '(save-buffers-kill-terminal :which-key "Quit Emacs")

      "cl" '(comment-line :which-key "comment line")

      "hf" '(describe-function :which-key "Describe Function")
      "hk" '(describe-key :which-key "Describe Key")
      "ha" '(apropos-command :which-key "Apropos Command")

      ;; window
      "wh"  '(evil-window-left :which-key "move left")
      "wj"  '(evil-window-down :which-key "move down a window")
      "wk"  '(evil-window-up :which-key "move up a window")
      "wl"  '(evil-window-right :which-key "move right a window")
      "wv"  '(split-window-right :which-key "split right a window")
      "ws"  '(split-window-below :which-key "split bottom")
      "ff"  '(find-file :which-key "find-file")
      "ot"  '(eshell :which-key "eshell")
      <<general-core-keybinds>>
      )
    )
#+end_src

** general core keybinds
  :PROPERTIES:
  :header-args: :noweb-ref general-core-keybinds :tangle no
  :END:
*** Window
 #+begin_src emacs-lisp
       ;; window bindings
 #+end_src
**** =SPC w m=: toggle-maximize-buffer
***** binding
 #+begin_src emacs-lisp
       "wm"  '(toggle-maximize-buffer :which-key "maximize buffer")
 #+end_src
***** toggle-maximize-buffer
 #+begin_src emacs-lisp :noweb-ref general-init :tangle no
 (defun toggle-maximize-buffer () "Maximize buffer"
	       (interactive)
	       (if (= 1 (length (window-list)))
		   (jump-to-register '_)
		 (progn
		   (window-configuration-to-register '_)
		   (delete-other-windows))))
 #+end_src
*** buffer
 #+begin_src emacs-lisp
       ;; buffer bindings
 #+end_src
**** =SPC b d=: kill-this-buffer
***** binding
 #+begin_src emacs-lisp
       "bd" '(my/kill-this-buffer :which-key "Kill Buffer")
 #+end_src
***** kill-this-buffer
 #+begin_src emacs-lisp :noweb-ref general-init :tangle no
   (defun my/kill-this-buffer (&optional arg)
     "Kill the current buffer.
	      If the universal prefix argument is used then kill also the window."
     (interactive "P")
     (if (window-minibuffer-p)
	 (abort-recursive-edit)
       (if (equal '(4) arg)
	   (kill-buffer-and-window)
	 (kill-buffer))))
 #+end_src
 
* Narrowing framework: Selectrum + others
** Core framework Selectrum 

#+begin_src nix :noweb-ref emacs-package :tangle no
( selectrum.override (args: {
                melpaBuild = drv: args.melpaBuild (drv // {
                  src = final.pkgs.fetchFromGitHub {
                    owner = "raxod502";
                    repo = "selectrum";
                    rev = "38279bb74b41f235c37640f079ffdaf8332166e";
                    sha256 = "oqWGw8gaqfge7j8iNySHfPat6nKCOXo+q2dWXIsZ0Pg=";
                  };
                });
              }) )
#+end_src

#+begin_src emacs-lisp
  (use-package selectrum
    :config
    (setq selectrum-refine-candidates-function #'orderless-filter)
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    ;; I think this shouldn't be necessary because of
    ;; https://github.com/raxod502/selectrum/commit/a09ecdea6609fe69144c44959dd016b32d14bf03
    ;;(setq selectrum-fix-vertical-window-height t)
    (selectrum-mode +1)
    (selectrum-prescient-mode +1)
    (prescient-persist-mode +1)
    :general

    )
#+end_src

** Orderless

#+begin_src nix :noweb-ref emacs-package :tangle no
orderless
#+end_src

#+begin_src emacs-lisp
  (use-package orderless
      :ensure t
      :init (icomplete-mode) ; optional but recommended!
      :custom (completion-styles '(orderless)))
#+end_src

** Prescient is configured with selectrum (it seems)
#+begin_src nix :noweb-ref emacs-package :tangle no
selectrum-prescient
#+end_src
** TODO Consult (ivy equivalent)
   #+begin_quote
   Consult provides various handy commands based on the Emacs completion function completing-read, which allows to quickly select an item from a list of candidates. Consult offers in particular a more advanced buffer switching command consult-buffer to switch to buffers and recently opened files. Various search commands are provided, like an asynchronous consult-grep, and consult-line, which resembles Swiper or Helm-Swoop. Multiple of the offered commands are greatly enhanced in comparison to their existing Emacs equivalents. The command consult-imenu presents a flat list of the Imenu with live preview and narrowing support. Please take a look at the full list of commands!
   #+end_quote
*** TODO consult

#+begin_src nix :noweb-ref emacs-package :tangle no
projectile
consult-flycheck
( consult.override (args: {
      melpaBuild = drv: args.melpaBuild (drv // {
        src = final.pkgs.fetchFromGitHub {
          owner = "minad";
          repo = "consult";
          rev = "f2bf17847dfb19852b0c4499e72ea29570b578bb";
          sha256 = "+62VWTTP48n7Tjv4Sr9pr/+guQTcisUkzJb64BhzOaQ=";
        };
      });
    }) )
#+end_src

#+begin_src emacs-lisp :noweb yes
  (use-package projectile) ;; TODO see if I can replace consult projectile dependencies with project.el
  (use-package consult
  :init

  ;; Configure register preview function.
  ;; This gives a consistent display for both `consult-register' and
  ;; the register preview when editing registers.
  (setq register-preview-delay 0
        register-preview-function #'consult-register-preview)

  <<consult-init>>

  ;; Configure other variables and modes in the :config section, after lazily loading the package
  :config

  (autoload 'projectile-project-root "projectile")
  (setq consult-project-root-function #'projectile-project-root)
  :general
  (my-leader-def
    :states '(normal visual emacs motion)
    :prefix "SPC"
    :keymaps 'override
    :non-normal-prefix "M-SPC"
    "bb"  '(consult-buffer :which-key "consult-buffer")
    "br"  '(consult-recent-file :which-key "consult-recent-file")
    "ss"  '(consult-line :which-key "consult-line")
    <<consult-keybinds>>
    ))
  (use-package consult-flycheck
    :bind (:map flycheck-command-map
                ("!" . consult-flycheck)))
#+end_src
**** TODO use newer version of consult to get around error
at least I think the newer version fixes this

#+begin_example
Error in post-command-hook (#[0 "\301\303 \240\210\300\304=\204, \305 \306\307\310\311\312\313!\314\"\315\316%\300<\203$ \300\202& \300C\"\262\205: \317\320!\211\2058 
\301\242\"\262\207" [any ("~/") consult--preview-function minibuffer-contents-no-properties any this-single-command-keys seq-find make-byte-code 257 "\301!\300\232\207" vconcat vector [vconcat] 3 "

(fn X)" run-hook-with-args-until-success consult--completion-candidate-hook] 8]): (void-function nil)
#+end_example

This error should have been fixed [[https://github.com/minad/consult/issues/13#issuecomment-735747194][here]] by a commit on Nov 3, 2020 which I thought I had... but maybe it's different.

Nope, I see that I install rev 4b7830f620e93f74608abb537229f2034d95a40a in [[*consult][consult]] which is from Feb 14, 2021.

I'm not sure, so I created an issue in https://github.com/minad/consult/issues/231.

*** TODO finish consult keybinds

*** marginala

#+begin_src nix :noweb-ref emacs-package :tangle no
( marginalia.override (args: {
      melpaBuild = drv: args.melpaBuild (drv // {
        src = final.pkgs.fetchFromGitHub {
          owner = "minad";
          repo = "marginalia";
          rev = "c5e89cf4220196205f6d6ce21f5cef87d186c1b4";
          sha256 = "0q700f4apxrygz9c25grih7mji2bshnskjsn16gyi7b4wdsyqvnm";
        };
      });
    }) )
#+end_src

For some reason Marginalia doesn't even load... not sure why. I bet it's because marginalia isn't actually on melpa yet so there isn't anything to override above.

#+begin_src emacs-lisp :tangle no
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  :bind (:map minibuffer-local-map
              ("C-M-a" . marginalia-cycle)
         ;; When using the Embark package, you can bind `marginalia-cycle' as an Embark action!
         ;;:map embark-general-map
         ;;     ("A" . marginalia-cycle)
        )

  ;; The :init configuration is always executed (Not lazy!)
  :init
  (require 'marginala)

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode)

  ;; When using Selectrum, ensure that Selectrum is refreshed when cycling annotations.
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))

  ;; Prefer richer, more heavy, annotations over the lighter default variant.
  ;; E.g. M-x will show the documentation string additional to the keybinding.
  ;; By default only the keybinding is shown as annotation.
  ;; Note that there is the command `marginalia-cycle' to
  ;; switch between the annotators.
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
)
#+end_src

* easy to access private journal

** add org capture template

#+begin_src emacs-lisp :noweb-ref org-capture-config :tangle no
  (add-to-list 'org-capture-templates
               '("j" "Journal" entry
                 (file+datetree "~/org/journal.org.gpg") "* %?\nEntered on %U\n  %i\n  %a"))
#+end_src


** define function to call capture template programatically

#+begin_src emacs-lisp :noweb-ref org-capture-init :tangle no
  (defun codygman/org-go-to-journal ()
    (interactive)
    (org-capture nil "j"))
#+end_src


** add keybinding that calls that function

#+begin_src emacs-lisp :noweb-ref org-capture-keybinds :tangle no
  "oj" 'codygman/org-go-to-journal
#+end_src


** default to my gpg key and don't prompt

#+begin_src emacs-lisp :noweb-ref epa-config :tangle no
(setq epa-pinentry-mode 'loopback)
#+end_src

#+begin_src emacs-lisp :noweb-ref epa-file-config :tangle no
(setq epa-file-encrypt-to '("cody@codygman.dev"))
(setq epa-file-select-keys nil)
#+end_src


** close all gpg buffers after 1 minute of idle time
#+begin_src emacs-lisp :noweb-ref epa-init :tangle no
(defun kill-gpg-buffers ()
  "Kill GPG buffers."
  (interactive)
  (let ((buffers-killed 0))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (string-match ".*\.gpg$" (buffer-name buffer))
          (message "Auto killing .gpg buffer '%s'" (buffer-name buffer))
          (when (buffer-modified-p buffer)
            (save-buffer))
          (kill-buffer buffer)
          (setq buffers-killed (+ buffers-killed 1)))))
    (unless (zerop buffers-killed)
      ;; Kill gpg-agent.
      (shell-command "gpgconf --kill gpg-agent")
      (message "%s .gpg buffers have been autosaved and killed" buffers-killed))))

(run-with-idle-timer 60 t 'kill-gpg-buffers)
#+end_src


* easy access to workout journal

** add org capture template

#+begin_src emacs-lisp :noweb-ref org-capture-config :tangle no
  (add-to-list 'org-capture-templates
               '("w" "Workout" entry
                 (file+datetree "~/org/workoutjournal.org") "* %?\nEntered on %U\n  %i\n"))
#+end_src


** define function to call capture template programatically

#+begin_src emacs-lisp :noweb-ref org-capture-init :tangle no
  (defun codygman/org-go-to-workout ()
    (interactive)
    (org-capture nil "w"))
#+end_src


** add keybinding that calls that function

#+begin_src emacs-lisp :noweb-ref org-capture-keybinds :tangle no
  "ow" 'codygman/org-go-to-workout
#+end_src

** allow inserting/copying/viewing images from phone into workout journal

I'll just generally fix this in [[*make working with images in org mode nice][make working with images in org mode nice]].

* tab bar mode (move?)

    #+begin_src emacs-lisp
      (use-package tab-bar
        :config
        (setq tab-bar-close-button-show nil)
        (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
        (setq tab-bar-close-tab-select 'recent)
        (setq tab-bar-new-tab-choice t)
        (setq tab-bar-new-tab-to 'right)
        (setq tab-bar-position nil)
        (setq tab-bar-show t)
        (setq tab-bar-tab-hints nil)
        (setq tab-bar-tab-name-function 'tab-bar-tab-name-all) ;; 'tab-bar-tab-name-current) ;;

        ;; (tab-bar-mode 1)
        ;; (tab-bar-history-mode -1)
        (require 'tab-bar)
        (tab-bar-mode 1)
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'override
          :non-normal-prefix "M-SPC"
          :prefix "SPC"
          "tl"  'tab-bar-select-tab-by-name
          "tr"  'tab-bar-rename-tab
          "tt"  'tab-bar-new-tab
          "tc"  'tab-bar-close-tab
          "tm"  'tab-bar-move-tab
          "tn"  'tab-bar-switch-to-next-tab ;; error autoloading and defining this func?
          "tp"  'tab-bar-switch-to-prev-tab ;; error autoloading and defining this func?
          ))
    #+end_src
* dired
#+begin_src emacs-lisp :noweb yes
  (use-package dired
    :init
    <<dired-init>>
    :config
    <<dired-config>>
    (my-leader-def
      :states '(normal visual emacs motion)
      :prefix "SPC"
      :keymaps 'override
      :non-normal-prefix "M-SPC"
      <<dired-keybinds>>
      )
    )
#+end_src

** dired-jump with =SPC o -=
#+begin_src emacs-lisp :noweb-ref dired-keybinds
  "o-"   '(dired-jump :which-key "Dired Jump")
#+end_src

* TODO which-key
* magit 
** configure git nix module
   
   First pass we'll just move the entire nix file inside of a nix source block.
   
   Should it stay that way? should more be done to it? idk... think about it

 #+BEGIN_SRC nix :tangle ../../../../users/profiles/git/default.nix :noweb yes :mkdirp yes
{
  programs.git = {
    enable = true;
    userName = "codygman";
    userEmail = "cody@codygman.dev";

    aliases = {
      a = "add -p";
      co = "checkout";
      cob = "checkout -b";
      f = "fetch -p";
      c = "commit";
      p = "push";
      ba = "branch -a";
      bd = "branch -d";
      bD = "branch -D";
      d = "diff";
      dc = "diff --cached";
      ds = "diff --staged";
      r = "restore";
      rs = "restore --staged";
      st = "status -sb";

      # reset
      soft = "reset --soft";
      hard = "reset --hard";
      s1ft = "soft HEAD~1";
      h1rd = "hard HEAD~1";

      # logging
      lg =
        "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit";
      plog =
        "log --graph --pretty='format:%C(red)%d%C(reset) %C(yellow)%h%C(reset) %ar %C(green)%aN%C(reset) %s'";
      tlog =
        "log --stat --since='1 Day Ago' --graph --pretty=oneline --abbrev-commit --date=relative";
      rank = "shortlog -sn --no-merges";

      # delete merged branches
      bdm = "!git branch --merged | grep -v '*' | xargs -n 1 git branch -d";
    };
  };
}
 #+end_src

** config

#+begin_src nix :noweb-ref emacs-package :tangle no
magit
#+end_src

#+begin_src emacs-lisp
  (use-package magit
:init
;; TODO write test for this
(add-hook 'with-editor-mode-hook 'evil-insert-state)

:general
(my-leader-def
  :states '(normal visual emacs motion)
  :prefix "SPC"
  :keymaps 'override
  :non-normal-prefix "M-SPC"
  :prefix "SPC"
  "gs" 'magit-status
  "gd" 'magit-dispatch
    "gl" 'magit-log
  )
)
#+end_src
** add evil bindings to magit
   This is now done in [[*evil collection][evil collection]]
*** TODO make =?= in magit do backwards search

I find myself wanting this all the time... though I should also make magit-dispatch something useful there too.

Isn't there something else I'm always pressing in magit buffers expecting to work??

* TODO fuzzy paste buffer history                    :superpower:

** description/hype
  
  This is very powerful. Nearly every persons workflow I've ever seen consists of lots of copy pasting.
  
  While wielding the very powerful copy/paste hammer everyone shares a fear of "oh crap I copied over something important and can't paste it now".

  solution 1: copy buffer history
  
  Then the problem arises of "I've copied 1000 things in the past hour and I want text containing 'Tom was' to paste in this document'.
  
  solution 2: fuzzy search and filtering (aka narrowing) of text

** consult-yank gets us part of the way there just by binding to it

#+begin_src emacs-lisp :noweb-ref consult-keybinds
  "pr"  '(consult-yank :which-key "consult-yank")
#+end_src

** TODO fix evil mode integration

*** DONE create a bug for fixing it on [[https://github.com/minad/consult/issues][minad/consult issues]]

https://github.com/minad/consult/issues/221


*** TODO insert *after* point by default like vim/evil's =p= and =evil-paste-after=

This code works for this heading and it's next sibling:

#+name: custom-consult-yank-code-1
#+begin_src emacs-lisp
  (defcustom selectrum-yank-after-point nil "docs")

  (defun consult-yank ()
    "Select text from the kill ring and insert it."
    (interactive)
    (let ((text (consult--yank-read)))
      (if (string-match-p "\n" text)
          (next-line)
        (forward-char 1))
      (setq yank-window-start (window-start))
      (push-mark)
      (insert-for-yank text)
      (setq this-command 'yank)
      nil))

  (setq selectrum-yank-after-point t)
#+end_src

https://github.com/minad/consult/issues/221#issuecomment-781718795

*** TODO insert anything with newlines *after current line* by default, or before with universal argument

*** TODO fix preview to use next-line or forward-char heuristic from [[custom-consult-yank-code-1][custom-consult-yank-code-1]]

#+name: custom-consult-yank-code-preview-1
#+begin_src emacs-lisp :tangle no
  ;; NOTE does not work for some reason
  ;; https://github.com/minad/consult/issues/221#issuecomment-781793894
    (defun consult--yank-read ()
      "Open kill ring menu and return selected text."
      (consult--read
       "Yank text: "
       (consult--remove-dups kill-ring)
       :history t ;; disable history
       :sort nil
       :category 'kill-ring
       :require-match t
       :preview
       ;; If previous command is yank, hide previously yanked text
       (let* ((ov) (pt (point)) (mk (or (and (eq last-command 'yank) (mark t)) pt)))
         (lambda (cand restore)
           (if restore
               (when ov (delete-overlay ov))
             (unless ov (setq ov (consult--overlay (min pt mk) (max pt mk) 'invisible t)))
             ;; Use `add-face-text-property' on a copy of "cand in order to merge face properties
             (setq cand (copy-sequence cand))
             (add-face-text-property 0 (length cand) 'consult-preview-yank t cand)
             ;; Use the `before-string' property since the overlay might be empty.
             (overlay-put ov 'before-string cand))))))
#+end_src


foo

*** TODO fix consult-yank trimming trailing newline on paste

** preserve yank history up to 1000

#+begin_src emacs-lisp :noweb-ref consult-init
  (setq kill-ring-max 1000)
#+end_src


** TODO make sure text from native X11 applications gets inserted into kill ring
   There is a simple variable we can set that just makes this work IIRC

* TODO indirect buffer based workflows                           :superpower:

Indirect buffers let you turn an org heading into a buffer of it's own, while ensuring any modifications go into the main file.

This might seem simple or not super useful, but for some reason it's very powerful to be able to split off views into fuzzy searchable buffers.

** TODO bind org-tree-to-indirect-buffer to =SPC o i=

#+begin_src emacs-lisp :noweb-ref consult-keybinds
  "oi"  '(org-tree-to-indirect-buffer :which-key "org-tree-to-indirect-buffer")
#+end_src

* TODO auto-identify code pasted into org document and put in source block
* TODO "your code as a crime scene" interactively               :superpower:
** description/hype
  
https://github.com/ag91/code-compass

Imagine being able to toggle a buffer that shows the other files frequently edited with your currently open buffer.

Imagine being able to see who the predominant author over the life of a file is according to git.

Imagine being notified if you're changing a file or programming module with lots of "churn" that could be tricky and require more unit tests.

You'd never want to be without it after!
** TODO try out the quickest/hackiest way
** notes on tryout
** TODO nixify everything
*** TODO Figure out how to nixify clojure projects like code-maat
* TODO super flexible lightweight code snippets                  :superpower:
  With yasnippet. Can also define snippets in this document or even perhaps in the language specific sections.

  Orrrr... I could even define them as part of a workflow description.
* eshell as my main shell
#+begin_src emacs-lisp :noweb yes
  ;; (defun disable-company-mode ()
  ;;   (company-mode 0))
  (use-package eshell
    ;; :after 'esh-autosuggest ;; TODO this isn't added back yet
    :init
    <<eshell-init>>
    ;; TODO add this back when fish/esh-autosuggest are working
    ;; :hook
    ;; (add-hook (eshell-mode . disable-company-mode))
    :config
    <<eshell-config>>
    (use-package em-term
      :config
      <<eshell-config-em-term>>
    )
    (my-leader-def
      :states '(normal visual emacs motion)
      :prefix "SPC"
      :keymaps 'override
      :non-normal-prefix "M-SPC"
      <<eshell-keybinds>>
      )
    )
#+end_src
** use a sane history value
   By default it's 128 :S
   #+begin_src emacs-lisp
   (setq eshell-history-size 1000000)
   #+end_src
** aliases
  :PROPERTIES:
  :header-args: :tangle eshell/alias :mkdirp true
  :END:
*** =gs=
#+begin_src emacs-lisp 
alias gs (magit-status)
#+end_src
*** =ff=
#+begin_src emacs-lisp 
alias ff find-file $1
#+end_src
*** =ffo=
#+begin_src emacs-lisp 
alias ffo find-file-other-window $1
#+end_src
*** =...= 
#+begin_src emacs-lisp 
alias ... cd ../..
#+end_src
*** =-=
#+begin_src emacs-lisp 
alias - cd -
#+end_src
*** =suspend=
#+begin_src emacs-lisp
alias suspend systemctl suspend
#+end_src
*** TODO =visual=
    should call =eshell-exec-visual=, but might want to wait until [[*make =eshell-exec-visual= tramp aware][make =eshell-exec-visual= tramp aware]]
** visual commands (run in term-mode)
*** nmtui
#+begin_src nix :noweb-ref eshell-config-em-term :tangle no
(add-to-list 'eshell-visual-commands "nmtui")
#+end_src
** close visual commands when done
   #+begin_src emacs-lisp
   (setq eshell-destroy-buffer-when-process-dies t)
   #+end_src
** TODO autocompletion for directory names without =cd=
   Given being in directory /home/cody with:

   #+begin_example
   ls /home/cody
   #+end_example

   you get completions from =cd ba<tab>=

   but not from =ba<tab>=

   This is because by default autocompletions are for something else you want: program names

   I want both though and then I'll disambiguate

** TODO list out "workspaces" to autosetup/go to from eshell
** TODO fish history suggestion
   
currently broken:

https://github.com/dieggsy/esh-autosuggest/issues/12

#+begin_src nix :noweb-ref emacs-package :tangle no
esh-autosuggest
#+end_src

TODO figure out how to disable other company mode things that might interfere here

#+begin_src emacs-lisp :tangle no
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode)
  :init
  )
#+end_src

** TODO fish autocompletion

TODO this and company don't work well.

TODO even if you disable company the suggestions don't have docs :/

TODO unliterate

#+begin_src nix :noweb-ref emacs-package :tangle no
fish-completion
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package emacs-fish-completion
  :when (executable-find "fish")
  :config
  (global-fish-completion-mode)
  )
#+end_src
** TODO make =eshell-exec-visual= tramp aware
*** enables
cd /ssh:cody@192.168.1.151:/home/cody/smurf
/ssh:cody@192.168.1.151:/home/cody/smurf $ eshell-exec-visual "./develop.sh"
*** here's an example that makes *only* ssh tramp-aware with eshell-exec-visual
    #+begin_src emacs-lisp :tangle no
      (defun eshell-exec-visual (&rest args)
	"Run the specified PROGRAM in a terminal emulation buffer.
      ARGS are passed to the program.  At the moment, no piping of input is
      allowed."
	(let* (eshell-interpreter-alist
	       (original-args args)
	       (interp (eshell-find-interpreter (car args) (cdr args)))
	       (in-ssh-tramp (and (tramp-tramp-file-p default-directory)
				  (equal (tramp-file-name-method
					  (tramp-dissect-file-name default-directory))
					 "ssh")))
	       (program (if in-ssh-tramp
			    "ssh"
			  (car interp)))
	       (args (if in-ssh-tramp
			 (let ((dir-name (tramp-dissect-file-name default-directory)))
			   (eshell-flatten-list
			    (list
			     "-t"
			     (tramp-file-name-host dir-name)
			     (format
			      "export TERM=xterm-256color; cd %s; exec %s"
			      (tramp-file-name-localname dir-name)
			      (string-join
			       (append
				(list (tramp-file-name-localname (tramp-dissect-file-name (car interp))))
				(cdr args))
			       " ")))))
		       (eshell-flatten-list
			(eshell-stringify-list (append (cdr interp)
						       (cdr args))))))
	       (term-buf
		(generate-new-buffer
		 (concat "*"
			 (if in-ssh-tramp
			     (format "%s %s" default-directory (string-join original-args " "))
			   (file-name-nondirectory program))
			 "*")))
	       (eshell-buf (current-buffer)))
	  (save-current-buffer
	    (switch-to-buffer term-buf)
	    (term-mode)
	    (set (make-local-variable 'term-term-name) eshell-term-name)
	    (make-local-variable 'eshell-parent-buffer)
	    (setq eshell-parent-buffer eshell-buf)
	    (term-exec term-buf program program nil args)
	    (let ((proc (get-buffer-process term-buf)))
	      (if (and proc (eq 'run (process-status proc)))
		  (set-process-sentinel proc 'eshell-term-sentinel)
		(error "Failed to invoke visual command")))
	    (term-char-mode)
	    (if eshell-escape-control-x
		(term-set-escape-char ?\C-x))))
	nil)
    #+end_src

   https://gist.github.com/ralt/a36288cd748ce185b26237e6b85b27bb
** TODO make tramp faster
*** TODO ssh controlmaster config (the big one)
*** misc
    #+begin_src emacs-lisp
      ;; cache file-name forever
      (setq remote-file-name-inhibit-cache nil)

      ;; make sure vc stuff is not making tramp slower
      (setq vc-ignore-dir-regexp
	    (format "%s\\|%s"
		    vc-ignore-dir-regexp
		    tramp-file-name-regexp))

      ;; not sure why we have this? just cargo-culting from an answer I saw
      ;; online.
      (setq tramp-verbose 1)

      ;; projectile has the fun side-effect of wanting to calculate the
      ;; project name, which makes tramp oh-so-much-slower.
      (setq projectile-mode-line "Projectile")
 #+end_src
** TODO detect bin directory of nix users

   ~NOTE~: This needs put within a =use-package tramp= block

    #+begin_src emacs-lisp :tangle no
    (add-to-list 'tramp-remote-path "~/.nix-profile/bin")
    #+end_src

** TODO make magit work smoothly over tramp
   Right now it just hangs, probably because I'm not using [[*ssh controlmaster config (the big one)][ssh controlmaster config (the big one)]]

   Though this also deserves consideration:

   https://emacs.stackexchange.com/questions/33845/magit-with-tramp-is-slow

* Project handling with project.el

#+begin_src emacs-lisp :noweb yes
  (use-package project
:ensure nil
:init
;; TODO write test for this
:general
(my-leader-def
  :states '(normal visual emacs motion)
  :prefix "SPC"
  :keymaps 'override
  :non-normal-prefix "M-SPC"
  :prefix "SPC"
  <<project_el-bindings>>
  )
)
#+end_src
** bindings
  :PROPERTIES:
  :header-args: :noweb-ref project_el-bindings :tangle no
  :END:
*** find filename in project
#+begin_src emacs-lisp
"SPC" 'project-find-file
#+end_src
*** find symbol in project
#+begin_src emacs-lisp
  "sp" 'consult-ripgrep
#+end_src
* TODO Data driven keybinding creation and analysis with key-freq

  Try to err on the side of only creating keybindings for commands/long commands/unergonomic command sthat show up frequently in key-freq

  #+begin_src nix :noweb-ref emacs-package :tangle no
  ( keyfreq.override (args: {
      melpaBuild = drv: args.melpaBuild (drv // {
        src = final.pkgs.fetchFromGitHub {
          owner = "dacap";
          repo = "keyfreq";
          rev = "e5fe9d585ce882f1ba9afa5d894eaa82c79be4f4";
          sha256 = "12m1jy8m8i39b809qbxx9g3r066jxhqwfyf5mqbd1lzlaw63b1i7";
        };
      });
    }) )
  #+end_src

  #+begin_src emacs-lisp
    (use-package keyfreq
      :config
      (setq keyfreq-excluded-commands
	    '(self-insert-command
	      ;; do I want to exclude these?
	      ;; do I actually need to exclude the evil variants?
	      forward-char
	      backward-char
	      previous-line
	      next-line
	      org-self-insert-command
	      general-dispatch-self-insert-command-0
	      evil-delete-backward-char-and-join
	      ))
      (keyfreq-mode 1)
      (keyfreq-autosave-mode 1))
  #+end_src


  See also:

   - [[http://blog.binchen.org/posts/how-to-be-extremely-efficient-in-emacs.html][How to be extremely efficient in Emacs]]
   - https://github.com/dacap/keyfreq

* direnv integration so nix things work magically
** TODO install direnv program from home-manager literately
** config
#+begin_src nix :noweb-ref emacs-package :tangle no
direnv
#+end_src

#+begin_src emacs-lisp
  (use-package direnv
    :init 
    :config
    ;; changing directory in eshell should force direnv-update
    (add-hook 'eshell-directory-change-hook #'direnv-update-directory-environment)
    (direnv-mode))
#+end_src
** notes
*** This needs to load _after_ the =flycheck-haskell= package (when we install it again)
    Otherwise the right version of ghc, the one specified by a project's shell.nix, will not be used.
* TODO password management in emacs with bitwarden
* TODO make org mode nice to use
** TODO make sure =RET= is =org-return= in evil mode
** TODO make sure notes go into drawer?
** TODO make working with images in org mode nice
*** allow viewing images

**** Always display images in org mode

#+begin_src emacs-lisp :noweb-ref org-config-setq :tangle no
  org-startup-with-inline-images t
#+end_src

**** Make sure images aren't enormous

***** install imagemagick so it's available to emacs

#+begin_src nix :noweb-ref emacs-system-dep :tangle no
imagemagick
#+end_src

***** set actual image width to 400 by default

I think 400 might allow images whose height is too high but we'll see for now.

Maybe the solution will be fixing how =evil-scroll-down= scrolls when images are in view.

Actually, in vanilla emacs =scroll-up-command= and =scroll-down-command= take images into account and:

- select the image as it comes into view
- scroll slow to center the image
- then scroll past it normally

I'll create an issue in the evil repo for this since that would be a nice improvement for evil users.

[[https://github.com/emacs-evil/evil/issues/1426][Make evil-scroll-down emulate scroll-down-command behavior on images in org mode #1426]]

For the time being I'll set a lower width to get around the unintuitive scrolling behavior.

#+begin_src emacs-lisp :noweb-ref org-config-setq :tangle no
  org-image-actual-width 350
#+end_src

**** test image

[[file:~/org/haskell_logo_2.png]]

*** TODO allow drag/drop and pasting images into org buffers with =org-download=

** TODO tracking time/doing stuff

*** TODO log time when something is marked as done

This is useful in combination with [[*log time something is created (only works with org capture!)][log time something is created (only works with org capture!)]]

*** TODO log time something is created (only works with org capture!)
** TODO use uuids for org-id (org links)

Make subheading clashes a thing of the past.

It may be nice however to use a blend of uuids and readable link names... I remember an article about this somewhere
** TODO figure out nice workflow/bindings for 
*** TODO create heading 
*** TODO create heading under
*** TODO create subheading 
    not sure how to do this
*** TODO create subheading under
    not sure how to do this
*** TODO demote heading
    default is okay I think?
    
    doesn't work in normal mode always? huh
*** TODO promote heading
    default is okay I think?

    doesn't work in normal mode always? huh
** center org mode with olivetti
#+begin_src nix :noweb-ref emacs-package :tangle no
olivetti
#+end_src

#+begin_src emacs-lisp
    (use-package olivetti
      :hook ((org-mode . olivetti-mode)
	     (org-mode . org-indent-mode))
      :custom
      (olivetti-body-width 0.65)
      (olivetti-minimum-body-width 65)
  )
#+end_src
** TODO marking heading as done will move to next heading or parent if no siblings
   This should help introduce inertia to completing todo lists :)
** TODO drag+drop images into org mode document
** TODO screenshot directly into org mode document
** TODO screenrecord direclty into org mode document (image+RET to play video)lc
** TODO warn when creating a heading very similar to others created in the past :future:superpower:
* TODO executable code snippets with org-babel
    #+begin_src emacs-lisp :noweb yes
      (use-package ob
	:config
	(org-babel-do-load-languages
	 'org-babel-load-languages
	 '(
	   <<org-babel-languages>>
	   )
	 ))
    #+end_src
** evaluate without confirmation
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src
** languages
  :PROPERTIES:
  :header-args: :noweb-ref org-babel-languages :tangle no
  :END:
*** elisp
    #+begin_src emacs-lisp
    (emacs-lisp . t)
    #+end_src
*** sh
    #+begin_src emacs-lisp
    (shell . t)
    #+end_src
**** TODO run shellcheck on shell blocks live
*** TODO haskell
**** TODO lsp org babel block integration
*** TODO restclient
* TODO develop [[https://notes.andymatuschak.org/Evergreen_notes][Evergreen notes]] with org-roam
** TODO basic setup
#+begin_src nix :noweb-ref emacs-package :tangle no
org-roam
#+end_src
** TODO export to html
https://github.com/org-roam/org-roam/issues/156
https://github.com/org-roam/org-roam-server

* TODO Basic lsp-mode config

* TODO Haskell integration

** TODO install latest ghc on nix unstable pin                   :unliterate:
   [[file:~/current-flk-nixos-user/profiles/develop/haskell/default.nix::pkgs.ghc]]

** TODO install latest haskell-language-server
   [[file:~/current-flk-nixos-user/profiles/develop/haskell/default.nix::pkgs.haskell-language-server]]

** haskell mode

  #+begin_src nix :noweb-ref emacs-package :tangle no
  haskell-mode
  #+end_src

  #+begin_src emacs-lisp
    (use-package haskell-mode
      :mode ("\\.hs\\'" . haskell-mode)
      :init
      (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
      (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
      :config
      (setq haskell-process-show-debug-tips nil)
     )
  #+end_src

  
** haskell lsp-mode integration

  #+begin_src nix :noweb-ref emacs-package :tangle no
  lsp-mode
  lsp-haskell
  lsp-ui
  #company
  #+end_src

    #+begin_src emacs-lisp
      (use-package lsp-mode
        :hook (
               (haskell-mode . lsp-deferred)
               (lsp-mode . lsp-enable-which-key-integration)
               ((js2-mode rjsx-mode) . lsp)
               )
        :commands (lsp lsp-deferred)
        :config
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'haskell-mode-map ;; TODO isn't there an lsp mode map?
          :non-normal-prefix "M-SPC"
          :prefix "SPC"
          "ca" '(lsp-execute-code-action :wk "lsp execute code action")
          )
        )

      (use-package lsp-haskell
        :init
        (setq lsp-haskell-process-path-hie "haskell-language-server")
        (setq lsp-haskell-process-args-hie nil)
        )
      (general-def
        :prefix ", c"
        :states '(normal visual)
        :keymaps 'haskell-mode-map
        "L" 'flycheck-list-errors
        "b" 'flycheck-buffer
        "c" 'flycheck-clear
        "l" 'lsp-ui-flycheck-list
        "n" 'flycheck-next-error
        "p" 'flycheck-previous-error)

      (use-package lsp-ui
        :commands lsp-ui-mode
        :config
        ;; (setq lsp-ui-flycheck-live-reporting nil)
        ;; (setq lsp-ui-sideline-enable nil)
        ;; (setq lsp-ui-doc-enable nil)
        ;; (setq lsp-ui-sideline-show-diagnostics nil)
        (setq lsp-ui-sideline-enable t
              ;; disable flycheck setup so default linter isn't trampled
              lsp-ui-flycheck-enable nil
              lsp-ui-sideline-show-symbol nil
              lsp-ui-sideline-show-hover nil
              lsp-ui-sideline-show-code-actions nil
              lsp-ui-peek-enable nil
              lsp-ui-imenu-enable nil
              lsp-ui-doc-enable nil)
        )

      ;; TODO move company to own block
      (use-package company
        :diminish t
        :config
        (setq company-minimum-prefix-length 1
              company-idle-delay 0.4
              company-selection-wrap-around t
              company-dabbrev-downcase nil
              )
        (global-company-mode)
        )
    #+end_src


** TODO flycheck integration

*** TODO flycheck haskell config if necessary

*** TODO realistic test: get pandoc/flycheck working correctly on nix

**** current error 

#+begin_example
  Completed    commonmark-0.1.1.4 (lib)

  Failed to build digest-0.0.1.2. The failure occurred during the configure
  step.
  Build log (
  /home/cody/.cabal/logs/ghc-8.10.3/digest-0.0.1.2-aca48d14a01856d53a590bf5d311ac479379d48684eefb8ae6508529aa308dba.log
  ):
  Configuring digest-0.0.1.2...
  cabal: Missing dependency on a foreign library:
  ,* Missing (or bad) header file: zlib.h
  ,* Missing (or bad) C library: z
  This problem can usually be solved by installing the system package that
  provides this library (you may need the "-dev" version). If the library is
  already installed but in a non-standard location then you can use the flags
  --extra-include-dirs= and --extra-lib-dirs= to specify where it is.If the
  library file does exist, it may contain errors that are caught by the C
  compiler at the preprocessing stage. In this case you can re-run configure
  with the verbosity flag -v3 to see the error messages.
  If the header file does exist, it may contain errors that are caught by the C
  compiler at the preprocessing stage. In this case you can re-run configure
  with the verbosity flag -v3 to see the error messages.


  cabal: Failed to build digest-0.0.1.2 (which is required by pandoc-2.11.4).
  See the build log above for details.


#+end_example

I'm not sure how to resolve the zlib issue on nixos for cabal... maybe it's just a package I can install?

**** install zlib (might want to move this later)

It's in unliterate:

[[file:~/flk/profiles/develop/haskell/default.nix::pkgs.ghc]]

**** TODO figure out how to tell flycheck in nix where to find zlib in a vanilla cabal project

*** TODO integration tests

Interaction between direnv/haskell/flycheck can be flaky so integration tests are useful and justified here even though they seem heavyweight.


** TODO ghci repl

*** TODO automatically open a ghci repl when emacs starts in ~

*** TODO configure ghci to be convenient for common tasks
**** TODO lenses
**** TODO =text= and =bytestring= for actually opening the files
**** TODO concise csv handling with lens-csv
https://hackage.haskell.org/package/lens-csv
**** TODO concise json parsing with lens-aeson
**** TODO try lens-filesystem and maybe include
**** TODO streaming with pipes, conduit, and maybe streamly

*** TODO automatically load files from certiain modes into ghci and split below
**** TODO automatically load json files when switched to and split ghci window below


* TODO all instant messaging in emacs
** TODO discord
   I already have this in the less than ideal [[file:~/current-flk-nixos-user/profiles/graphical/default.nix::discord][format]].
   
   https://search.nixos.org/packages?channel=20.09&show=bitlbee-discord&from=0&size=30&sort=relevance&query=bitlbee

** TODO signal?
* TODO try elfeed (and rss in general) out
* Weave/tangle nix overlays and emacs module
** tangle overlay with emacs packages

 #+BEGIN_SRC nix :tangle ../../../../overlays/emacsGcc.nix :noweb yes :mkdirp yes
final: prev: {

      emacsGcc =
        let
          package = prev.emacsGcc;
          emacsPackages = prev.emacsPackagesNgGen package;
          emacsWithPackages = emacsPackages.emacsWithPackages;
          <<emacs-package-in-let>>
        in emacsWithPackages (epkgs: with epkgs; [
          <<emacs-package>>
        ]);

}
 #+END_SRC

** tangle module with emacs system dependencies

 #+BEGIN_SRC nix :tangle ../../../../profiles/develop/emacs/default.nix :noweb yes :mkdirp yes
 { pkgs, ... }: {

   environment.systemPackages = with pkgs; [
     <<emacs-system-dep>>
   ];
 }
 #+end_src

** tangle emacs early-init.el

  ~NOTE~ This will only work on subsequent loads of emacs *after* this is tangled to the filesystem   

 #+BEGIN_SRC emacs-lisp :tangle early-init.el :noweb yes
 <<early-init>>
 #+end_src

* "boot" into eshell
 #+BEGIN_SRC emacs-lisp
   (eshell)
 #+end_src

** TODO make order not matter for this

   currently this needs to be at the end of the config for it to work

   One thing we could do is nest all of the headings into some common noweb-ref and then tangle them accordingly.

   Yeah, we should do that.

* TODO Finish rest of config
** DONE binding for find-file 
** DONE binding for switch buffer
** DONE hide toolbar/etc
** DONE hide autosave files (see system crafters video)
** TODO add other things
* use package
  NOTE: current plan to put all use-package declarations in here

** exwm
*** install package
#+begin_src nix :noweb-ref emacs-package :tangle no
exwm
exwm-edit
#+end_src
*** config
    #+begin_src emacs-lisp
      (use-package exwm
        :init
        (setq exwm-input-global-keys
              `(([?\s-r] . exwm-reset)
                ([?\s-i] . exwm-input-release-keyboard)
                ;; convenience keybinding, meant to mimic `esc' in Vim bindings
                ([?\s-\ ] . app-launcher-run-app)
                ([?\s-\[] . exwm-reset)))
        (defun exwm-rename-buffer ()
          (interactive)
          (exwm-workspace-rename-buffer
           (concat exwm-class-name ": "
                   (if (<= (length exwm-title) 150) exwm-title
                     (concat (substring exwm-title 0 149) "...")))))

        ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
        (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
        (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
        :config
        (require 'exwm)

        ;; TODO fix this
        (require 'exwm-systemtray)
        (exwm-systemtray-enable)
        (exwm-enable)
        ;; stop exwm from catching SPC leader key.
        ;; the double whitespace is intentional
        ;; credit https://github.com/matthuszagh/emacs/blob/5827a8d2ca4e97bf37cfa71dabf9346043573798/layers/exwm-layer.el#L112
        (add-to-list 'exwm-input-prefix-keys ?\  )
        )

      (use-package exwm-edit
        :config
        ;; TODO do I have an equivalent of this?
        (defun ag-exwm/on-exwm-edit-compose ()
          ;; (spacemacs/toggle-visual-line-navigation-on)
          (funcall 'markdown-mode))
        (add-hook 'exwm-edit-compose-hook 'ag-exwm/on-exwm-edit-compose))
    #+end_src
*** notes
**** make sure by default clicking links opens in same tab, or when I use =f= in firefox to highlight/select a link using vimium or saka
#+begin_example 
# default for this was 2 for me, set to 0
browser.link.open_newwindow.restriction

# default was 0 for me, need to set to 1
browser.link.open_newwindow.restriction
#+end_example

***** see 
       #+begin_example 
         Hello iSkyiera

         In the Location bar, type about:config and press Enter. The about:config "This might void your warranty!" warning page may appear.

         Click I'll be careful, I promise!, to continue to the about:config page.

         At the Search area type(or copy/paste the next)
         browser.link.open_newwindow.restriction then, double-click on it
         and change the value to 0 (zero)

         click OK. 

         Do the same with the :
         browser.link.open_newwindow
         and change the value to 1 (one) 
       #+end_example

** winner

    #+begin_src emacs-lisp :noweb yes
      <<winner-use-package>>
    #+end_src
** org

    #+begin_src emacs-lisp :noweb yes
      (use-package org
        :config
        (setq org-adapt-indentation nil
              org-hide-leading-stars t)
        (setq
              <<org-config-setq>>
        )
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'override
          :non-normal-prefix "M-SPC"
          <<org-keybinds>>
          )
        )
    #+end_src

    #+begin_src emacs-lisp :noweb yes
      (use-package org-capture
        :init
        <<org-capture-init>>
        :general
        (my-leader-def
          :states '(normal visual emacs motion)
          :prefix "SPC"
          :keymaps 'override
          :non-normal-prefix "M-SPC"
          :prefix "SPC"
          "oc" '(org-capture :wk "org capture")
          <<org-capture-keybinds>>
          )
        :config
        (add-hook 'org-capture-mode-hook 'evil-insert-state)
        (lambda () ) ;; this is here just in case org-mode-config noweb-ref is empty

        <<org-capture-config>>
        )
    #+end_src
** epa (gpg)

    #+begin_src emacs-lisp :noweb yes
      (use-package epa
	:init
	(lambda () ) ;; this is here just in case noweb-ref is empty
	:config
	(lambda () ) ;; this is here just in case noweb-ref is empty

	<<epa-config>>)
      (use-package epa-file
	:init
	(lambda () ) ;; this is here just in case noweb-ref is empty

	<<epa-init>>
	:config
	(lambda () ) ;; this is here just in case noweb-ref is empty

	<<epa-file-config>>
       )
    #+end_src
** recentf
#+begin_src emacs-lisp :noweb yes
(use-package recentf
  :config
  (recentf-mode)
  (setq  recentf-max-saved-items 1000
         recentf-exclude '("^/var/folders\\.*"
                          "COMMIT_EDITMSG\\'"
                          ".*-autoloads\\.el\\'"
                          "[/\\]\\.elpa/")))
    #+end_src

* TODO remove non home-manager emacs and move files into home-manager emacs directory
* Tangle/reload on save
** make sure our local variables are marked as safe to avoid prompt
#+begin_src emacs-lisp :noweb yes
  (setq safe-local-variables-values '())
  (add-to-list 'safe-local-variables-values
               '((cons nil '(add-hook 'after-save-hook (lambda ()(if (y-or-n-p "Reload?")(load-file user-init-file))) nil t))
               (cons nil '(add-hook 'after-save-hook (lambda ()(if (y-or-n-p "Tangle?")(org-babel-tangle))) nil t))
               ))
#+end_src
** the local variables
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda ()(if (y-or-n-p "Reload?")(load-file user-init-file))) nil t) 
# eval: (add-hook 'after-save-hook (lambda ()(if (y-or-n-p "Tangle?")(org-babel-tangle))) nil t) 
# End:
